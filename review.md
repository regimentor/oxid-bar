# Код-ревью: `modules/audio` (PulseAudio backend)

## Контекст и область ревью

- Ревью сфокусировано на crate `modules/audio` и его PulseAudio backend (`libpulse-binding`).
- На текущий момент явной интеграции с `bar/` не обнаружено (использование `audio::` встречается только в `modules/audio/src/main.rs`), поэтому замечания ниже — про качество модуля и готовность к будущей интеграции.

Источники:
- `modules/audio/src/backend/pulse/client.rs`
- `modules/audio/src/main.rs`
- `modules/audio/src/lib.rs`

---

## Критичные проблемы (исправить в первую очередь)

### 1) Потенциальная вечная блокировка `Client::start_listening()`

`Client` хранит `cmd_channels.tx`, поэтому `rx.recv()` может **никогда не завершиться**, даже если backend-поток завершился/упал: sender остаётся живым внутри `Client`.

Наблюдение по коду:
- `start_listening()` клонирует sender и спавнит поток.
- Затем читает `rx.recv()` в цикле `while let Ok(...)`.
- Но сам `Client` продолжает удерживать `cmd_channels.tx`, из-за чего канал не “закроется” естественным образом.

### 2) Нет механизма остановки backend

`lesten_pulse_backend()` содержит бесконечный `loop` без условия выхода и без stop-канала/флага. Это затрудняет корректное завершение приложения/перезапуск.

### 3) Ошибки backend-потока теряются

`std::thread::spawn(move || lesten_pulse_backend(cmd_tx));` возвращает `JoinHandle`, но результат `anyhow::Result<()>` нигде не обрабатывается и не логируется.

---

## Существенные проблемы дизайна/поддерживаемости

### 1) Канал событий не используется

- `AudioEvent` — пустой enum.
- `EventChannels` создаётся и хранится в `Client`, но нигде не применяется.

Это создаёт шум и усложняет понимание архитектуры (как будто события планировались, но не реализованы).

### 2) Не обрабатываются удаления (и часть событий)

В subscribe callback обрабатываются только:
- `Facility::SinkInput` + `Operation::New | Operation::Changed`

При этом:
- `Operation::Removed` игнорируется — `outputs` будет накапливать “мертвые” записи.

### 3) `ChangeOutput` фактически ничего не меняет

Сейчас это только логирование — обновления `self.outputs` по `index` нет.

### 4) Семантика `OutputInfo` неоднозначна

`OutputInfo` заполняется и из `SinkInputInfo`, и из `SinkInfo`.

- Для sink-input:
  - `index` = sink-input index
  - `sink` = sink index
  - `client` = client index (Option)
- Для sink:
  - `index` = sink index
  - `sink` = sink index
  - `client` = None

Из-за этого один тип описывает разные сущности. Для поддержки/расширения проще:
- либо разделить типы (`SinkView` / `SinkInputView`),
- либо сделать enum-обёртку с явным variant.

### 5) Громкость может быть > 100%

PulseAudio допускает значения выше `Volume::NORMAL`. Сейчас `volume_level` считается как процент без ограничений, что может “сломать” UI/логики, если ожидается 0..=100.

---

## Мелкие замечания (низший приоритет)

- Опечатка в имени функции: `lesten_pulse_backend` вероятно должно быть `listen_pulse_backend`.
- Неиспользуемые импорты: `Mutex`, `RwLock` (в текущем состоянии файла).
- `modules/audio/src/main.rs` выглядит как демо/черновик (включая `println!("Hello, world!")`). Если бинарник не нужен — лучше убрать; если нужен — оформить как нормальный CLI/example.

---

## Рекомендации по улучшению (конкретно)

- Развести ответственность “PulseAudio слушатель/бекенд” и “потребитель состояния”.
  - Клиенту обычно достаточно `Receiver`/stream-а событий + структуры состояния.
  - `Sender`/PulseAudio mainloop должны жить и управляться внутри backend-части.
- Добавить корректное завершение:
  - stop-канал/флаг, обработка выхода из mainloop, прогнозируемый shutdown.
- Доработать обработку подписок:
  - `Removed` + актуализация/удаление из `outputs`.
- Нормализовать модель данных:
  - разнести sink vs sink-input на разные типы или явно пометить variant.
- Повысить тестируемость:
  - вынести “чистые” преобразования и операции над списком (add/update/remove) в функции, которые можно unit-тестировать без PulseAudio.


## Вопрос по целевому дизайну

Какой целевой формат вы хотите для `modules/audio`?
- библиотечный API для `bar/` (подписка на события/состояние в памяти),
- или отдельный процесс/демон, а бар будет общаться через IPC?


